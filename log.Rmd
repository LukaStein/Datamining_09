---
title: "Logbook parkinson dysphonia"
author: "L T Stein"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Introduction

The data is extracted from Kaggle and its article is published on ncbi by Max A. Little, Patrick E. McSharry, Eric J. Hunter, Lorraine O. Ramig (2008). 'Suitability of dysphonia measurements for telemonitoring of Parkinson's disease', *IEEE Transactions on Biomedical Engineering (to appear)*.

Background information..

The research paper's goal is to find out if healthy people can be discerned from people with Parkinson's disease using different sorts of voice recordings.
Based on the data that the article gives as appendix, the purpose of this project is to find out what attribute or attributes are most important to give a diagnose of possible sickness. Therefore given that goal the project's research question states: "What voice measurements can be identified as nodes using machine learning algorithms whom discerns a Parkinson's patient from a healthy person?"

---

# Read data


First a look of what the data looks like from a .csv file. The data is divided
by header and is comma separated. 


```{r}
patient.data <- read.table("parkinsons.data", header = T, sep = ",")
head(patient.data)
```

Verify if everything is read correctly.

```{r}
cat(ncol(patient.data), "columns and", nrow(patient.data), "rows")
```

There are 2 nominal and 22 numeric columns.


Showing the amount of recordings of healthy people and sick people. The original labels
of one and zero are replaced respectfully with sick and healthy 

```{r}
# Adding labels instead of "1" and "0"
patient.data$status[patient.data$status == "1"] <- "sick"
patient.data$status[patient.data$status == "0"] <- "healthy"


amount.sick.recordings <- sum(patient.data$status == "sick")
amount.healthy.recordings <- sum(patient.data$status == "healthy")
cat(" There are [", amount.sick.recordings, "] recordings of Parkinson patients.\n",
    "There are [", amount.healthy.recordings, "] recordings of healthy people.\n",
    "In total there are: [", amount.sick.recordings + amount.healthy.recordings, "] recordings.")
```


In order to make it more clear what the data means, the columns are put into a table.


```{r}
columns <- colnames(patient.data)
definitions <- read.csv("definitions.csv", header = FALSE, sep = ",")
attributes <- data.frame(Attributes = c(columns),
                          Unit = c("-", rep("Hz", 3), "%", "ms", rep("-", 4), "dB", rep("-", 13)),
                         Datatype = c(sapply(patient.data, class)[1]),
                         Definition = c(definitions[1]))
head(attributes)
```

**Retrospective**
All the data is read correctly with the corresponding amount of rows and columns
as the article suggests. 


---

## Explorative Data Analysis

It's important to check if there are any NA or missing values.

```{r}
cat("There are", sum(is.na(patient.data)), "missing values")
```

**Retrospective**
No NA values are found.


By applying a summary to the dataset's dataframe, its statistical meanings are returned.

```{r}
head(summary(patient.data))
```
Based on the names different groups are formed for visualisation

```{r}
MDVP.large <- 2:4
MDVP.small <- 5:9
MDVP.shimmer <- 10:15
NHR.HNR <- 16:17
RPDE.DEA <- 19:20
spread <- 21:22
D2.PPE <- 23:24
```

Install and load required packages
```{r}
#install.packages("ggcorrplot")
#install.packages("ggplot2")
library("ggplot2")
library("ggcorrplot")
```

Boxplotting the data to show the differences in MDVP measured attributes containing large numbers.

```{r}
ggplot(patient.data$MDVP.Fo.Hz.[patient.data$status == "sick"] ~ patient.data$MDVP.Fo.Hz.[patient.data$status == "healthy"] + geom_boxplot())
```

Overview of all boxplots

```{r}
par(mfrow=c(3,3))
boxplot(patient.data[MDVP.large])
boxplot(patient.data[MDVP.small])
boxplot(patient.data[MDVP.shimmer])
boxplot(patient.data[NHR.HNR])
boxplot(patient.data[RPDE.DEA])
boxplot(patient.data[spread])
boxplot(patient.data[D2.PPE])
```
*Retrospective*

Due to the small values it was difficult to fully show each boxplot per attribute.


Histogram of attributes in order to see if the attribute data is normally distributed.

```{r}
#par(mfrow = c(3,8))
#for (i in 1:ncol(patient.data)) {
#  if (is.numeric(patient.data[, i])) {
#  hist(patient.data[, i], col = "lightblue",
#       main = colnames(patient.data[i]))
#  }
  
#}
```
*Retrospective*

Most data seems distributed to the left, only a quarter has normal distributed data.

Barplot for showing amount of sick and healthy people

```{r}
barplot(c(amount.sick.recordings, amount.healthy.recordings), 
        legend.text = c("Sick", "Healthy"), col = c("deeppink3", "darkolivegreen1"),
        main = "Number of healthy and sick people",
        xlab = "Status",
        ylab = "Amount of people")
```
*Retrospective*

In this dataset there are nearly thrice as much people recorded whom are sick opposing to healthy people.

Pair plot showing if attributes form pairs thus have correlating data. Only the groups that have correlations above 0.9 are plotted.

```{r}
# load library needed for ggpairs
library(GGally)

data.numeric <- subset(patient.data, select = c(-name, -status))
ggpairs(data.numeric[MDVP.small-2], ggplot2:: aes(color=patient.data$status), progress = FALSE)
```

The columns MDVP.PPQ and MDVP.RAP correlate the best in difference. Though MDVP.RAP and MDVP.Jitter perform the best correlation value of 0.990.

```{r}
ggpairs(data.numeric[MDVP.shimmer-2], ggplot2:: aes(color=patient.data$status), progress = FALSE)
```
Attributes Shimmer.APQ4 and MDVP.Shimmer show the best correlation in the plot above. Though many shimmer and MDVP attributes perform highly.


A correlation heatmap using ggcorplot. It takes a matrix of the numeric data en a matrix of their p-values. Since the dataset is too large for a pretty heatmap, it's split into two.

```{r}
# creating two matrices
corr.matrix1 <- cor(data.numeric[1:12])
corr.matrix2 <- cor(data.numeric[11:22])
corr.matrix3 <- cor(data.numeric[1:6], data.numeric[16:22])
# plotting heat map
ggcorrplot(corr.matrix1, lab = T, lab_size = 2, lab_col = "black")
ggcorrplot(corr.matrix2, lab = T, lab_size = 2, lab_col = "black")
ggcorrplot(corr.matrix3, lab = T, lab_size = 2, lab_col = "black")
```


# Bibliography

Link about EDA
https://r4ds.had.co.nz/exploratory-data-analysis.html 
Link article
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5434464/ 

